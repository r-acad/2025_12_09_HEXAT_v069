# FILE: .\src\IO\Postprocessing.jl

module Postprocessing

using JSON, Printf
using ..Mesh
using ..MeshUtilities 
using ..ExportVTK
import MarchingCubes: MC, march

export export_iteration_results, export_smooth_watertight_stl

"""
    get_smooth_nodal_densities(density, elements, nNodes)
    
Averages element densities to nodes to create a smooth field for isosurface extraction.
"""
function get_smooth_nodal_densities(density::Vector{Float32}, elements::Matrix{Int}, nNodes::Int)
    node_sums = zeros(Float32, nNodes)
    node_counts = zeros(Int, nNodes)
    nElem = length(density)
    
    @inbounds for e in 1:nElem
        rho = density[e]
        for i in 1:8
            node_idx = elements[e, i]
            node_sums[node_idx] += rho
            node_counts[node_idx] += 1
        end
    end
    nodal_density = zeros(Float32, nNodes)
    @inbounds for i in 1:nNodes
        if node_counts[i] > 0
            nodal_density[i] = node_sums[i] / Float32(node_counts[i])
        end
    end
    return nodal_density
end

function trilinear_interpolate(vals, xd::Float32, yd::Float32, zd::Float32)
    c00 = vals[1]*(1f0-xd) + vals[2]*xd
    c01 = vals[4]*(1f0-xd) + vals[3]*xd
    c10 = vals[5]*(1f0-xd) + vals[6]*xd
    c11 = vals[8]*(1f0-xd) + vals[7]*xd
    c0 = c00*(1f0-yd) + c01*yd
    c1 = c10*(1f0-yd) + c11*yd
    return c0*(1f0-zd) + c1*zd
end

"""
    export_smooth_watertight_stl(...)
"""
function export_smooth_watertight_stl(density::Vector{Float32}, geom, threshold::Float32, filename::String; subdivision_level::Int=1)
    dir_path = dirname(filename)
    if !isempty(dir_path) && !isdir(dir_path); mkpath(dir_path); end

    NX, NY, NZ = geom.nElem_x, geom.nElem_y, geom.nElem_z
    dx, dy, dz = geom.dx, geom.dy, geom.dz
    
    nodes_coarse, elements_coarse, _ = Mesh.generate_mesh(NX, NY, NZ; dx=dx, dy=dy, dz=dz)
    nNodes_coarse = size(nodes_coarse, 1)
    
    if length(density) != size(elements_coarse, 1); return; end
    
    nodal_density_coarse = get_smooth_nodal_densities(density, elements_coarse, nNodes_coarse)
    grid_coarse = reshape(nodal_density_coarse, (NX+1, NY+1, NZ+1))

    sub_NX, sub_NY, sub_NZ = NX * subdivision_level, NY * subdivision_level, NZ * subdivision_level
    pad = 1 
    fine_dim_x, fine_dim_y, fine_dim_z = sub_NX+1+2*pad, sub_NY+1+2*pad, sub_NZ+1+2*pad
    sub_dx, sub_dy, sub_dz = dx/Float32(subdivision_level), dy/Float32(subdivision_level), dz/Float32(subdivision_level)

    fine_grid = zeros(Float32, fine_dim_x, fine_dim_y, fine_dim_z)
    x_coords = collect(Float32, range(-pad*sub_dx, step=sub_dx, length=fine_dim_x))
    y_coords = collect(Float32, range(-pad*sub_dy, step=sub_dy, length=fine_dim_y))
    z_coords = collect(Float32, range(-pad*sub_dz, step=sub_dz, length=fine_dim_z))

    Threads.@threads for k_f in (1+pad):(fine_dim_z-pad)
        for j_f in (1+pad):(fine_dim_y-pad)
            for i_f in (1+pad):(fine_dim_x-pad)
                ix, iy, iz = i_f-(1+pad), j_f-(1+pad), k_f-(1+pad)
                idx_x, idx_y, idx_z = div(ix, subdivision_level), div(iy, subdivision_level), div(iz, subdivision_level)
                
                if idx_x >= NX; idx_x = NX - 1; end
                if idx_y >= NY; idx_y = NY - 1; end
                if idx_z >= NZ; idx_z = NZ - 1; end
                
                c_i, c_j, c_k = idx_x + 1, idx_y + 1, idx_z + 1
                
                rem_x, rem_y, rem_z = ix - idx_x*subdivision_level, iy - idx_y*subdivision_level, iz - idx_z*subdivision_level
                xd, yd, zd = Float32(rem_x)/subdivision_level, Float32(rem_y)/subdivision_level, Float32(rem_z)/subdivision_level
                
                vals = (grid_coarse[c_i,c_j,c_k], grid_coarse[c_i+1,c_j,c_k], grid_coarse[c_i+1,c_j+1,c_k], grid_coarse[c_i,c_j+1,c_k],
                        grid_coarse[c_i,c_j,c_k+1], grid_coarse[c_i+1,c_j,c_k+1], grid_coarse[c_i+1,c_j+1,c_k+1], grid_coarse[c_i,c_j+1,c_k+1])
                fine_grid[i_f, j_f, k_f] = trilinear_interpolate(vals, xd, yd, zd)
            end
        end
    end

    mc_struct = MC(fine_grid, Int; normal_sign=1, x=x_coords, y=y_coords, z=z_coords)
    march(mc_struct, threshold)
    
    if length(mc_struct.triangles) == 0
        @warn "No isosurface found at threshold $threshold."
        return
    end

    try
        open(filename, "w") do io
            header_str = "Binary STL generated by HEXA TopOpt. Threshold: $threshold"
            header = zeros(UInt8, 80)
            len = min(length(header_str), 80)
            copyto!(header, 1, codeunits(header_str), 1, len)
            write(io, header)
            
            num_tris = UInt32(length(mc_struct.triangles))
            write(io, num_tris)
            
            for face in mc_struct.triangles
                v1 = mc_struct.vertices[face[1]]
                v2 = mc_struct.vertices[face[2]]
                v3 = mc_struct.vertices[face[3]]
                
                e1x = v2[1] - v1[1]; e1y = v2[2] - v1[2]; e1z = v2[3] - v1[3]
                e2x = v3[1] - v1[1]; e2y = v3[2] - v1[2]; e2z = v3[3] - v1[3]
                
                nx = e1y*e2z - e1z*e2y
                ny = e1z*e2x - e1x*e2z
                nz = e1x*e2y - e1y*e2x
                
                mag = sqrt(nx*nx + ny*ny + nz*nz)
                if mag > 1e-12
                    nx /= mag; ny /= mag; nz /= mag
                else
                    nx = 0.0f0; ny = 0.0f0; nz = 0.0f0
                end
                
                write(io, Float32(nx)); write(io, Float32(ny)); write(io, Float32(nz))
                write(io, Float32(v1[1])); write(io, Float32(v1[2])); write(io, Float32(v1[3]))
                write(io, Float32(v2[1])); write(io, Float32(v2[2])); write(io, Float32(v2[3]))
                write(io, Float32(v3[1])); write(io, Float32(v3[2])); write(io, Float32(v3[3]))
                write(io, UInt16(0))
            end
        end
    catch e
        @error "STL Save Failed: $e"
    end
end

"""
    export_binary_for_web(...)
    
    Writes compact binary for web visualizer AND checkpointing.
    Includes:
    1. Header (Magic, Version, Iter, R, Threshold, Count, Dims)
    2. Data Arrays (Centroids, Density, Stress)
    3. JSON Configuration (Full Dump + Aliases for Viewer)
"""
function export_binary_for_web(filename::String, 
                               nodes::Matrix{Float32}, 
                               elements::Matrix{Int}, 
                               density::Vector{Float32}, 
                               l1_stress::Vector{Float32},
                               principal_field::Matrix{Float32},
                               geom,
                               threshold::Float32,
                               iter::Int,
                               current_radius::Float32,
                               config::Dict)
    
    
    valid_indices = findall(x -> x >= threshold, density)
    count = length(valid_indices)
    
    if count == 0; return; end

    centroids_flat = zeros(Float32, count * 3)
    densities_out = density[valid_indices]
    signed_l1_out = zeros(Float32, count)

    Threads.@threads for i in 1:count
        idx = valid_indices[i]
        c = MeshUtilities.element_centroid(idx, nodes, elements)
        centroids_flat[3*(i-1)+1] = c[1]
        centroids_flat[3*(i-1)+2] = c[2]
        centroids_flat[3*(i-1)+3] = c[3]

        s1 = principal_field[1, idx]
        s2 = principal_field[2, idx]
        s3 = principal_field[3, idx]

        abs_max = abs(s1); sign_val = sign(s1)
        if abs(s2) > abs_max; abs_max = abs(s2); sign_val = sign(s2); end
        if abs(s3) > abs_max; abs_max = abs(s3); sign_val = sign(s3); end
        
        signed_l1_out[i] = l1_stress[idx] * sign_val
    end

    
    # We deepcopy the config to ensure we don't modify the runtime state 
    # and to capture ALL parameters (solver, growth, etc.), INCLUDING THE NEW 'SIZE' VECTOR
    meta = deepcopy(config)
    
    
    meta["iteration"] = iter
    meta["radius"] = current_radius
    meta["threshold"] = threshold
    
    
    # The visualizer expects an 'action' property ('add' or 'remove') to colorize shapes.
    # The new YAML config uses 'stiffness_ratio'. We iterate the geometry and 
    # inject 'action' based on the ratio so the visualizer works without modification.
    if haskey(meta, "geometry") && isa(meta["geometry"], Dict)
        for (key, shape) in meta["geometry"]
            if isa(shape, Dict) && haskey(shape, "type")
                # If 'action' is missing but 'stiffness_ratio' exists, synthesize it.
                if !haskey(shape, "action") && haskey(shape, "stiffness_ratio")
                    ratio = Float32(shape["stiffness_ratio"])
                    if ratio > 0
                        shape["action"] = "add"
                    else
                        shape["action"] = "remove"
                    end
                end
            end
        end
    end

    
    
    meta["loads"] = get(config, "external_forces", [])
    meta["bcs"] = get(config, "boundary_conditions", [])
    meta["settings"] = get(config, "optimization_parameters", Dict())
    
    json_str = JSON.json(meta)
    json_bytes = Vector{UInt8}(json_str)
    json_len = UInt32(length(json_bytes))

    open(filename, "w") do io
        
        write(io, 0x48455841) # Magic "HEXA" (UInt32)
        write(io, UInt32(2))  
        write(io, Int32(iter))
        write(io, Float32(current_radius))
        write(io, Float32(threshold))
        
        
        write(io, UInt32(count))
        write(io, Float32(geom.dx))
        write(io, Float32(geom.dy))
        write(io, Float32(geom.dz))

        
        write(io, Float32.(centroids_flat)) 
        write(io, Float32.(densities_out))
        write(io, Float32.(signed_l1_out))

        
        write(io, json_len)
        write(io, json_bytes)
    end
end

function export_iteration_results(iter::Int, base_name::String, RESULTS_DIR::String, 
                                  nodes::Matrix{Float32}, elements::Matrix{Int}, 
                                  U_full::Vector{Float32}, F::Vector{Float32}, 
                                  bc_indicator::Matrix{Float32}, principal_field::Matrix{Float32}, 
                                  vonmises_field::Vector{Float32}, full_stress_voigt::Matrix{Float32}, 
                                  l1_stress_norm_field::Vector{Float32}, principal_dir_field::Matrix{Float32},
                                  density::Vector{Float32}, E::Float32, geom;
                                  iso_threshold::Float32=0.8f0,
                                  current_radius::Float32=0.0f0,
                                  config::Dict=Dict(),
                                  save_bin::Bool=true,
                                  save_stl::Bool=true,
                                  save_vtk::Bool=true)
      
    iter_prefix = "iter_$(iter)_"

    
    if save_bin
        print("      > Writing Checkpoint/Web Binary...")
        t_web = time()
        bin_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_webdata.bin")
        
        # Pass 'config' down so we can extract shapes/loads/BCs
        export_binary_for_web(bin_filename, nodes, elements, density, l1_stress_norm_field, principal_field, geom, iso_threshold, iter, current_radius, config)
        @printf(" done (%.3fs)\n", time() - t_web)
    end

    
    if save_vtk
        print("      > Writing VTK (Paraview)...")
        t_vtk = time()
        solution_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_solution") 
        ExportVTK.export_solution(nodes, elements, U_full, F, bc_indicator, 
                                  principal_field, vonmises_field, full_stress_voigt, 
                                  l1_stress_norm_field, principal_dir_field; 
                                  
                                  density=density, threshold=iso_threshold, scale=Float32(1.0), filename=solution_filename) 
        @printf(" done (%.3fs)\n", time() - t_vtk)
    end

    
    if save_stl
        print("      > Writing Isosurface STL...")
        t_stl = time()
        stl_filename = joinpath(RESULTS_DIR, "$(iter_prefix)$(base_name)_isosurface.stl")
        
        export_smooth_watertight_stl(density, geom, iso_threshold, stl_filename; subdivision_level=1)
        @printf(" done (%.3fs)\n", time() - t_stl)
    end
end 

end