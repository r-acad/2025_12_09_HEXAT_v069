I have a Julia-based Topology Optimization codebase that currently uses a matrix-free Conjugate Gradient (CG) solver on the GPU (src/Solvers/GPUSolver.jl). I need to add an Algebraic Multigrid (AMG) preconditioner to improve convergence on difficult meshes.Please generate the code to implement this using a Hybrid CPU-AMG / GPU-Krylov strategy.Context & Requirements:Architecture:The main CG solver loop must remain on the GPU (Matrix-Free).The AMG library (AlgebraicMultigrid.jl) runs on the CPU.Setup Phase: Assemble the global stiffness matrix (SparseMatrixCSC) on the CPU for the active elements only, and build the AMG hierarchy using Smoothed Aggregation.Solve Phase: Inside the GPU CG loop, when applying the preconditioner ($z = M^{-1}r$): copy residual r from GPU to CPU $\to$ apply AMG V-cycle $\to$ copy result z back to GPU.File Modifications:src/Main.jl: Add AlgebraicMultigrid to the REQUIRED_PACKAGES list.src/Solvers/GPUSolver.jl:Add a helper function assemble_cpu_matrix_for_amg(...) that explicitly assembles the sparse stiffness matrix on the CPU. It must apply the density scaling exactly like the matrix-free operator does.Modify gpu_matrix_free_cg_solve(...) to check config["solver_parameters"]["preconditioner"].Implement the branching logic: If "amg", build the hierarchy. If setup fails (e.g., OOM), automatically fall back to the existing Jacobi preconditioner.Update the CG loop to handle the data transfer for the AMG step.Code Style:Keep the existing "Matrix-Free" GPU operator logic (apply_matrix_free_operator!).Ensure types are generic (where T) but assume Float32 is used for the GPU and Float64 might be required for the CPU AMG matrix if the library prefers it (or stick to T).Please provide the full updated code for:src/Main.jl (just the dependency update)src/Solvers/GPUSolver.jl (complete module replacement)